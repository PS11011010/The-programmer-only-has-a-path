/**
 * Реализовать метод, возвращающий факториал от заданного числа
 * https://t.me/c/1533281926/27
 * @param {Number} n 
 * @returns
 * @author PS11011010
 * @description Факториал, последовательность чисел Фибоначчи, Золотое сечение - все это
 * замечательный пример решения через рекурсию. Результат - это текущее состояние и еще информация,
 * полученная точно таким же способом, но уже для следующего параметра в последовательности.
 */
const factorial = (n) => {
    if (n === 0) {
        return 1;
    }

    return n * factorial(--n);
}

/**
 * Реализовать метод, возвращающий факториал от заданного числа
 * https://t.me/c/1533281926/27
 * @param {Number} n 
 * @returns
 * @author PS11011010
 * @description Факториал, последовательность чисел Фибоначчи, Золотое сечение - все это
 * замечательный пример решения через рекурсию. Результат - это текущее состояние и еще информация,
 * полученная точно таким же способом, но уже для следующего параметра в последовательности.
 * Почему же тут был применен Promise? Все дело в том, что глубина вызовов функция в JS ограничена
 * 500 шагами. 500 последовательных вызовов в цепочке. После превышения вывалится ошибка:
 * Uncaught RangeError: Maximum call stack size exceeded
 * Классическим решением является использование setTimeou в цепочке.
 * Подробнее, например, тут: https://habr.com/ru/post/167033/
 */
const factorialAsync = (n) => {
    if (n === 0) {
        return Promise.resolve(1);
    }
    const _n = n;

    return new Promise((resolve) => {
        factorialAsync(--n).then((result) => {
            resolve(_n * result);
        })
    })
}

module.exports = {
    factorial,
    factorialAsync
}